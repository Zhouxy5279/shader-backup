// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.


#include "fragmentVersionCentroidUV.h"
#include "uniformEntityConstants.h"


#include "uniformShaderConstants.h"
#include "util.h"

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;

#if defined(GLINT) && defined(USE_BLOOM)
#define GLINT_BLEND_BLOOM
#endif

#if defined(USE_MULTITEXTURE) || defined(GLINT_BLEND_BLOOM)
	LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;
#endif

varying vec4 light;
varying vec4 fogColor;

#ifdef COLOR_BASED
	varying vec4 vertColor;
#endif

#ifdef USE_OVERLAY
    // When drawing horses on specific android devices, overlay color ends up being garbage data.
    // Changing overlay color to high precision appears to fix the issue on devices tested
	varying highp vec4 overlayColor;
#endif

#ifdef TINTED_ALPHA_TEST
	varying float alphaTestMultiplier;
#endif

#ifdef GLINT
	varying vec2 layer1UV;
	varying vec2 layer2UV;
	varying vec4 tileLightColor;
	varying vec4 glintColor;
#endif

vec4 glintBlend(vec4 dest, vec4 source) {
	// glBlendFuncSeparate(GL_SRC_COLOR, GL_ONE, GL_ONE, GL_ZERO)
	return vec4(source.rgb * source.rgb, abs(source.a)) + vec4(dest.rgb, 0.0);
}

#ifdef USE_EMISSIVE
#ifdef USE_ONLY_EMISSIVE
#define NEEDS_DISCARD(C) (C.a == 0.0 || C.a == 1.0 )
#else
#define NEEDS_DISCARD(C)	(C.a + C.r + C.g + C.b == 0.0)
#endif
#else
#ifndef USE_COLOR_MASK
#define NEEDS_DISCARD(C)	(C.a < 0.5)
#else
#define NEEDS_DISCARD(C)	(C.a == 0.0)
#endif
#endif

#if defined(USE_ALPHA) || defined(USE_BRIGHT)
uniform vec4 HIDE_COLOR;
#endif


// ava funcs
uniform highp float TIME;
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
	vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec2 random_dir(vec2 pos)
{
	return vec2(fract(sin(dot(pos.xy, vec2(6.66, 7.77)))*8.88), fract(sin(dot(pos.xy, vec2(8.88, 7.77)))*6.66));
}

mat2 Rot(float a) {
    float s=sin(a), c=cos(a);
    return mat2(c,-s,s,c);
}

float Cross(vec2 uv, float a, float sparkle) {  //  float
    vec2 av1 = abs(uv);
 	vec2 av2 = abs(uv*Rot(a));
    vec2 av = min(av1, av2);
    
    float fu = floor(av2[0] * 250.);
    float fv = floor(av2[1] * 250.);
    float m = fu + fv;
    
    if (fu < 4. && fv < 1.) {
        return m;
    }
    else if (fu < 1. && fv < 4.) {
        return m;
    }
    else if (fu == 4. && fv == 0. && mod(TIME, 0.5) < 0.15) {
        return m/1.;
    }
    else if (fu == 0. && fv == 4. && mod(TIME, 0.5) < 0.15) {
        return m/1.;
    }
    else if (fu == 5. && fv == 0. && mod(TIME, 0.5) < 0.3 && mod(TIME, 1.) > 0.15) {
        return m/1.;
    }
    else if (fu == 0. && fv == 5. && mod(TIME, 0.5) < 0.3 && mod(TIME, 1.) > 0.15) {
        return m/1.;
    }
    else {
        return 0.;
    }

}


void main()
{
	vec4 color = vec4(1.0);

#ifdef USE_BLOOM
	vec4 bloomMask = vec4(1.0);
#endif

#ifndef NO_TEXTURE
#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
	color = texture2D( TEXTURE_0, uv );
#ifdef USE_BLOOM
#ifdef GLINT_BLEND_BLOOM
	bloomMask = texture2D( TEXTURE_2, uv);
#else
	bloomMask = texture2D( TEXTURE_1, uv);
#endif
#endif
#else
	color = texture2D_AA(TEXTURE_0, uv);
#ifdef USE_BLOOM
#ifdef GLINT_BLEND_BLOOM
	bloomMask = texture2D_AA(TEXTURE_2, uv);
#else
	bloomMask = texture2D_AA(TEXTURE_1, uv);
#endif
#endif
#endif // !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)

#ifdef MASKED_MULTITEXTURE
	vec4 tex1 = texture2D( TEXTURE_1, uv );

	// If tex1 has a non-black color and no alpha, use color; otherwise use tex1 
	float maskedTexture = float(dot( tex1.rgb, vec3(1.0, 1.0, 1.0) ) * ( 1.0 - tex1.a ) > 0.0);
	color = mix(tex1, color, maskedTexture);
#endif // MASKED_MULTITEXTURE

#if defined(ALPHA_TEST) && !defined(USE_MULTITEXTURE) && !defined(MULTIPLICATIVE_TINT)
	if(NEEDS_DISCARD(color))
		discard;
#endif // ALPHA_TEST

#ifdef TINTED_ALPHA_TEST
vec4 testColor = color;
testColor.a *= alphaTestMultiplier;
	if(NEEDS_DISCARD(testColor))
		discard;
#endif // TINTED_ALPHA_TEST
#endif // NO_TEXTURE

#ifdef COLOR_BASED
	color *= vertColor;
#endif

#ifdef MULTI_COLOR_TINT
	// Texture is a mask for tinting with two colors
	vec2 colorMask = color.rg;

	// Apply the base color tint
	color.rgb = colorMask.rrr * CHANGE_COLOR.rgb;

	// Apply the secondary color mask and tint so long as its grayscale value is not 0
	color.rgb = mix(color, colorMask.gggg * MULTIPLICATIVE_TINT_CHANGE_COLOR, ceil(colorMask.g)).rgb;
#else

#ifdef USE_COLOR_MASK
	color.rgb = mix(color.rgb, color.rgb*CHANGE_COLOR.rgb, color.a);
	color.a *= CHANGE_COLOR.a;
#endif

#ifdef ITEM_IN_HAND
	color.rgb = mix(color.rgb, color.rgb*CHANGE_COLOR.rgb, vertColor.a);
#if defined(MCPE_PLATFORM_NX) && defined(NO_TEXTURE) && defined(GLINT)
	// TODO(adfairfi): This needs to be properly fixed soon. We have a User Story for it in VSO: 102633
	vec3 dummyColor = texture2D(TEXTURE_0, vec2(0.0, 0.0)).rgb;
	color.rgb += dummyColor * 0.000000001;
#endif
#endif // MULTI_COLOR_TINT

#endif

#ifdef USE_MULTITEXTURE
	vec4 tex1 = texture2D( TEXTURE_1, uv );
	vec4 tex2 = texture2D( TEXTURE_2, uv );
	color.rgb = mix(color.rgb, tex1.rgb, tex1.a);
#ifdef ALPHA_TEST
	if (color.a < 0.5 && tex1.a == 0.0) {
		discard;
	}
#endif

#ifdef COLOR_SECOND_TEXTURE
	if (tex2.a > 0.0) {
		color.rgb = tex2.rgb + (tex2.rgb * CHANGE_COLOR.rgb - tex2.rgb)*tex2.a;//lerp(tex2.rgb, tex2 * changeColor.rgb, tex2.a)
	}
#else
	color.rgb = mix(color.rgb, tex2.rgb, tex2.a);
#endif
#endif

#ifdef MULTIPLICATIVE_TINT
	vec4 tintTex = texture2D(TEXTURE_1, uv);
#ifdef MULTIPLICATIVE_TINT_COLOR
	tintTex.rgb = tintTex.rgb * MULTIPLICATIVE_TINT_CHANGE_COLOR.rgb;
#endif

#ifdef ALPHA_TEST
	color.rgb = mix(color.rgb, tintTex.rgb, tintTex.a);
	if (color.a + tintTex.a <= 0.0) {
		discard;
	}
#endif
	
#endif

#ifdef USE_BLOOM
	//bloom overrides emissive
	color.rgb *= (bloomMask.r < 0.1) ? light.rgb : vec3(bloomMask.r);
#else
#ifdef USE_EMISSIVE
	//make glowy stuff
	color *= mix(vec4(1.0), light, color.a );
#else
	color *= light;
#endif
#endif

	//apply fog
	color.rgb = mix( color.rgb, fogColor.rgb, fogColor.a );

#ifdef GLINT
	// Applies color mask to glint texture instead and blends with original color
	vec4 layer1 = texture2D(TEXTURE_1, fract(layer1UV)).rgbr * glintColor;
	vec4 layer2 = texture2D(TEXTURE_1, fract(layer2UV)).rgbr * glintColor;
	vec4 glint = (layer1 + layer2) * tileLightColor;

	color = glintBlend(color, glint);
#endif

	//WARNING do not refactor this
#ifdef UI_ENTITY
	color.a *= HUD_OPACITY;
#endif

#ifdef USE_ALPHA
	color.a *= HIDE_COLOR.a;
#endif

#ifdef USE_BRIGHT
	color.rgb *= HIDE_COLOR.a;
#endif

	// ava funcs
	vec4 tex_color = texture2D(TEXTURE_0, uv);
	if (tex_color.a > 0.58 && tex_color.a < 0.59){
		float breath = sin(radians(TIME * 180.));
		vec3 c_hsv = rgb2hsv(tex_color.rgb);
		vec3 c_rgb = hsv2rgb(vec3(c_hsv.r, c_hsv.g, 0.75 + 0.25 * breath));
		gl_FragColor = vec4(c_rgb, 1.0);
	}
	else if (tex_color.a > 0.695 && tex_color.a < 0.705){
		float breath = sin(radians(TIME * 90.));
		vec3 c_hsv = rgb2hsv(tex_color.rgb);
		vec3 c_rgb = hsv2rgb(vec3(c_hsv.r, c_hsv.g - 0.2 * breath, 0.9 + 0.1 * breath));

		vec4 wave_frag = vec4(sin(length(vec2(floor((-uv[0])*32.), floor((1.-uv[1])*32.))*1.) - TIME*3.) * 1.2);
		vec4 crosses = vec4(0.0);
		
		for (int i = 1; i <= 70; i++){
			float cs = Cross(vec2(uv[0] - mod(random_dir(vec2(float(i)))[0] * TIME*-0.1, 1.), 1. - uv[1] - mod(random_dir(vec2(float(i)))[1] * TIME*-0.1, 1.)), TIME*2., 1.);
			if (cs > 0.)
				crosses = vec4(tex_color.rgb * cs * breath, 1.0);
    	}

		gl_FragColor = mix(mix(tex_color, wave_frag, 0.2), crosses, breath*0.8-wave_frag.r*0.4);
	}
	else {
		gl_FragColor = color;
	}

}
